<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Single-player Jigsaw Puzzle Maker</title>
  <style>
    :root{--ui-bg:#f6f7fb;--accent:#6750a4;--muted:#777}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,system-ui,Arial,sans-serif;background:var(--ui-bg);color:#222}
    .app{max-width:1100px;margin:28px auto;padding:18px;background:white;border-radius:12px;box-shadow:0 6px 26px rgba(20,20,40,0.08)}
    h1{margin:0 0 8px;font-size:20px}
    .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    label{font-size:13px;color:var(--muted)}
    input[type=file]{display:none}
    .btn{background:var(--accent);color:white;padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
    .btn.ghost{background:transparent;color:var(--accent);border:1px solid #e6e0f7}
    .select{padding:8px;border-radius:8px;border:1px solid #eee}
    .status{margin-left:auto;text-align:right;font-size:13px;color:var(--muted)}
    .board-wrap{position:relative;margin-top:16px;border:1px dashed #eee;height:640px;display:flex;align-items:center;justify-content:center;background:#fafafa;border-radius:8px}
    #board{position:relative;width:90%;height:90%;max-width:900px;max-height:560px;background:#ddd;overflow:hidden}
    .piece{position:absolute;touch-action:none;user-select:none;border-radius:6px;box-shadow:0 6px 14px rgba(10,10,30,0.12);cursor:grab;border:1px solid rgba(255,255,255,0.25);background-repeat:no-repeat;background-size:100% 100%}
    .piece.locked{box-shadow:none;cursor:default;border:1px solid rgba(0,0,0,0.06)}
    .toolbar{display:flex;gap:8px;margin-top:12px}
    .muted{color:var(--muted)}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(0deg, rgba(255,255,255,0.75), rgba(255,255,255,0.6));backdrop-filter:blur(2px);z-index:900;border-radius:8px}
    .completed-card{background:white;padding:22px;border-radius:10px;box-shadow:0 8px 30px rgba(20,20,50,0.12);text-align:center}
    .small{font-size:13px}
    .preview-toggle{display:flex;align-items:center;gap:6px}
  </style>
</head>
<body>
  <div class="app">
    <h1>Jigsaw Puzzle Maker — single player</h1>
    <div class="controls">
      <label class="btn" id="uploadBtn">Upload image
        <input id="file" type="file" accept="image/*">
      </label>
      <div>
        <label class="small muted">Difficulty</label>
        <select id="difficulty" class="select">
          <option value="5">Very easy — 5 pieces</option>
          <option value="20">Easy — 20 pieces</option>
          <option value="40" selected>Medium — 40 pieces</option>
          <option value="80">Hard — 80 pieces</option>
          <option value="100">Very hard — 100 pieces</option>
        </select>
      </div>

      <button id="start" class="btn">Start puzzle</button>
      <button id="shuffleBtn" class="btn ghost">Shuffle</button>
      <button id="showPreview" class="btn ghost">Toggle Preview</button>

      <div class="status">
        <div>Moves: <span id="moves">0</span></div>
        <div>Time: <span id="timer">00:00</span></div>
      </div>
    </div>

    <div class="board-wrap">
      <div id="board">
        <!-- Pieces will be injected here -->
      </div>
    </div>

    <div class="toolbar">
      <div class="muted small">Tip: Drag pieces into place. Pieces snap when close.</div>
    </div>
  </div>

  <template id="pieceTmpl">
    <div class="piece" draggable="false" ></div>
  </template>

  <script>
  // Single-file jigsaw puzzle maker

  // Grid presets for piece counts (rows x cols)
  const GRID_PRESETS = {
    5: [1,5],
    20: [4,5],
    40: [5,8],
    80: [8,10],
    100: [10,10]
  };

  const fileInput = document.getElementById('file');
  const uploadBtn = document.getElementById('uploadBtn');
  const startBtn = document.getElementById('start');
  const board = document.getElementById('board');
  const difficulty = document.getElementById('difficulty');
  const movesEl = document.getElementById('moves');
  const timerEl = document.getElementById('timer');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const previewBtn = document.getElementById('showPreview');

  let img = new Image();
  let srcDataUrl = null;
  let pieces = []; // {el, targetX,targetY,w,h,locked}
  let rows=0,cols=0;
  let moves=0;
  let timerInterval=null; let startTime=null;
  let previewOn=false;

  fileInput.addEventListener('change', async (e)=>{
    const f = e.target.files[0];
    if(!f) return;
    const url = await readFileAsDataURL(f);
    srcDataUrl = url;
    img = new Image();
    img.onload = ()=>{
      // auto-start when loaded
      createPuzzle();
    }
    img.src = url;
  });

  startBtn.addEventListener('click', ()=>{
    if(!srcDataUrl) return alert('Upload an image first');
    createPuzzle();
  });

  shuffleBtn.addEventListener('click', ()=>{
    shufflePieces();
  });

  previewBtn.addEventListener('click', ()=>{
    previewOn = !previewOn;
    if(previewOn) showPreview(); else hidePreview();
  });

  function readFileAsDataURL(file){
    return new Promise((res,rej)=>{
      const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file);
    })
  }

  function createPuzzle(){
    // reset
    clearBoard();
    moves=0; movesEl.textContent=0; timerEl.textContent='00:00';
    clearInterval(timerInterval); startTime=Date.now(); timerInterval=setInterval(updateTimer,500);

    const count = Number(difficulty.value);
    [rows,cols] = GRID_PRESETS[count] || gridFromCount(count);

    // compute board image fit box
    // We'll size the board to the image aspect ratio while fitting inside #board
    const boardRect = board.getBoundingClientRect();
    const maxW = boardRect.width; const maxH = boardRect.height;
    let imgW = img.width, imgH = img.height;
    let scale = Math.min(maxW / imgW, maxH / imgH);
    const dispW = Math.round(imgW * scale);
    const dispH = Math.round(imgH * scale);

    // create temporary canvas of scaled image for crisp backgrounds
    const tmp = document.createElement('canvas'); tmp.width=dispW; tmp.height=dispH;
    const ctx = tmp.getContext('2d'); ctx.drawImage(img,0,0,dispW,dispH);
    const scaledDataUrl = tmp.toDataURL();

    // clear and set board size
    board.innerHTML=''; board.style.width = dispW + 'px'; board.style.height = dispH + 'px';

    const pieceW = Math.floor(dispW / cols);
    const pieceH = Math.floor(dispH / rows);

    pieces = [];

    // create pieces with correct background-position
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = c*pieceW; const y = r*pieceH;
        const w = (c===cols-1)? dispW - x : pieceW;
        const h = (r===rows-1)? dispH - y : pieceH;

        const el = document.createElement('div');
        el.className='piece';
        el.style.width = w + 'px'; el.style.height = h + 'px';
        el.style.left = x + 'px'; el.style.top = y + 'px';
        el.dataset.r = r; el.dataset.c = c;
        el.dataset.tx = x; el.dataset.ty = y;
        el.style.backgroundImage = `url(${scaledDataUrl})`;
        el.style.backgroundSize = dispW + 'px ' + dispH + 'px';
        el.style.backgroundPosition = `-${x}px -${y}px`;

        // add a subtle jigsaw-like shape using border-radius and pseudo shadows (visual only)
        el.style.borderRadius = '6px';

        board.appendChild(el);
        pieces.push({el, targetX:x, targetY:y, w, h, locked:false});
      }
    }

    // shuffle pieces onto board area
    shufflePieces();
    // attach interactions
    attachPointerHandlers();
  }

  function fetchBoardSize(){ return board.getBoundingClientRect(); }

  function shufflePieces(){
    // place pieces randomly around board (inside board bounds). For fairness, randomize positions but keep fully inside
    const bBox = board.getBoundingClientRect();
    // We'll position pieces inside board area but offset from correct location
    pieces.forEach((p,i)=>{
      p.locked=false; p.el.classList.remove('locked');
      // random position anywhere within board, allow overlap
      const maxX = bBox.width - p.w; const maxY = bBox.height - p.h;
      const rx = Math.round(Math.random() * (maxX));
      const ry = Math.round(Math.random() * (maxY));
      p.el.style.left = rx + 'px'; p.el.style.top = ry + 'px';
      p.currentX = rx; p.currentY = ry;
      p.el.style.zIndex = 10 + Math.floor(Math.random()*50);
    });
    moves = 0; movesEl.textContent = moves;
  }

  function attachPointerHandlers(){
    pieces.forEach(p=>{
      const el = p.el;
      let offsetX=0, offsetY=0; let dragging=false;

      const onDown = (ev)=>{
        if(p.locked) return;
        ev.preventDefault();
        dragging=true;
        el.setPointerCapture(ev.pointerId);
        const rect = board.getBoundingClientRect();
        const ex = ev.clientX - rect.left; const ey = ev.clientY - rect.top;
        const left = parseFloat(el.style.left); const top = parseFloat(el.style.top);
        offsetX = ex - left; offsetY = ey - top;
        el.style.zIndex = 9999;
        el.style.cursor = 'grabbing';
      };

      const onMove = (ev)=>{
        if(!dragging) return;
        ev.preventDefault();
        const rect = board.getBoundingClientRect();
        const ex = ev.clientX - rect.left; const ey = ev.clientY - rect.top;
        let nx = ex - offsetX; let ny = ey - offsetY;
        // keep inside board
        nx = Math.max(0, Math.min(rect.width - p.w, nx));
        ny = Math.max(0, Math.min(rect.height - p.h, ny));
        el.style.left = nx + 'px'; el.style.top = ny + 'px';
        p.currentX = nx; p.currentY = ny;
      };

      const onUp = (ev)=>{
        if(!dragging) return;
        dragging=false;
        try{ el.releasePointerCapture(ev.pointerId); }catch(e){}
        el.style.cursor = 'grab';
        // check snap
        const dx = p.currentX - p.targetX; const dy = p.currentY - p.targetY;
        const dist = Math.hypot(dx,dy);
        const snapThreshold = Math.max(20, Math.min(p.w,p.h) * 0.35);
        if(dist <= snapThreshold){
          // snap
          el.style.left = p.targetX + 'px'; el.style.top = p.targetY + 'px';
          p.locked = true; p.el.classList.add('locked'); p.el.style.zIndex=5;
          checkCompletion();
        } else {
          // left where dropped
        }
        moves++; movesEl.textContent = moves;
      };

      el.addEventListener('pointerdown', onDown);
      window.addEventListener('pointermove', onMove);
      window.addEventListener('pointerup', onUp);
      // also pointercancel
      window.addEventListener('pointercancel', onUp);
    });
  }

  function checkCompletion(){
    if(pieces.every(p=>p.locked)){
      clearInterval(timerInterval);
      setTimeout(()=>{
        showCompleted();
      },200);
    }
  }

  function showCompleted(){
    const overlay = document.createElement('div'); overlay.className='overlay';
    const card = document.createElement('div'); card.className='completed-card';
    card.innerHTML = `<h2>Nice — puzzle complete</h2><p class="small">Moves: ${moves}<br>Time: ${timerEl.textContent}</p><div style="margin-top:12px;"><button id='doneClose' class='btn'>Close</button> <button id='restart' class='btn ghost'>Play again</button></div>`;
    overlay.appendChild(card);
    document.querySelector('.board-wrap').appendChild(overlay);
    document.getElementById('doneClose').addEventListener('click', ()=>overlay.remove());
    document.getElementById('restart').addEventListener('click', ()=>{ overlay.remove(); shufflePieces(); startTime=Date.now(); timerInterval=setInterval(updateTimer,500); });
  }

  function updateTimer(){
    if(!startTime) return;
    const s = Math.floor((Date.now() - startTime)/1000);
    const mm = String(Math.floor(s/60)).padStart(2,'0'); const ss = String(s%60).padStart(2,'0');
    timerEl.textContent = mm+':' + ss;
  }

  function showPreview(){
    // show a faint full-image overlay on board
    if(!srcDataUrl) return;
    const prev = document.createElement('div'); prev.id='previewOverlay'; prev.style.position='absolute'; prev.style.inset='0'; prev.style.zIndex=1000; prev.style.pointerEvents='none'; prev.style.backgroundImage=`url(${srcDataUrl})`;
    // scale to board size
    const b = board.getBoundingClientRect(); prev.style.backgroundSize = board.style.width + ' ' + board.style.height; prev.style.opacity=0.4;
    board.appendChild(prev);
  }
  function hidePreview(){
    const e = document.getElementById('previewOverlay'); if(e) e.remove();
  }

  function clearBoard(){
    board.innerHTML=''; hidePreview(); pieces=[]; clearInterval(timerInterval); startTime=null;
  }

  function gridFromCount(n){
    const r = Math.floor(Math.sqrt(n)); const c = Math.ceil(n / r); return [r,c];
  }

  // initialize small helper: allow clicking upload label to open file
  uploadBtn.addEventListener('click', ()=>{ fileInput.click(); });

  // initial empty board message
  board.innerHTML = `<div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:#666;text-align:center;max-width:80%"><div style='font-size:18px;margin-bottom:6px'>Upload an image to make a puzzle</div><div class='small muted'>Pick difficulty then press Start</div></div>`;
  </script>
</body>
</html>
